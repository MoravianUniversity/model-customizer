import requests 
import json
import re
import math
from collections import namedtuple


from ..config import ACCESS_KEY, SECRET_KEY


OnShapeDocInfo = namedtuple("OnShapeDocInfo", ('did', 'wv', 'wvid', 'eid'))

OPTION = r':\s*[^:,\n\]]+'
FLOAT = r'\s*[+-]?(?:[0-9]*[.])?[0-9]+\s*'
OPTIONS = rf'(\[{FLOAT}(?::{FLOAT}){{0,2}}\]|\[(?:{FLOAT},)+{FLOAT}\]|\[(?:{FLOAT}{OPTION}+\s*\,\s*)+{FLOAT}{OPTION}\s*\])'
#OPTIONS_AT_END = re.compile(rf"{OPTIONS}\s*$")
#OPTIONS_AT_START = re.compile(rf"^\s*{OPTIONS}")
INC_AT_END = re.compile(rf"\[\s*({FLOAT})\s*\]\s*$")
LEN_AT_END = re.compile(rf"\[\s*(\d+)\s*\]\s*$")


def get_variables(document_url):
    """
    Generates our JSON format based on a url. Starts by getting the onshape document variables, turning them into json, 
    and then formatting it correctly for our database.
    :param document_url: the url of the onshape document
    :return: the final json as a string
    """


    # Use the API keys generated from the Onshape developer portal 
    api_keys = (ACCESS_KEY, SECRET_KEY)

    variable_url = get_variable_url(get_doc_info(document_url))
    configuration_url = get_configuration_url(get_doc_info(document_url))

    variable_feature_json = fetch_document_variable_features_json(api_keys, variable_url)
    configuration_json = fetch_document_configuration_json(api_keys, configuration_url)

    # our_json_features = feature_json_to_our_json(variable_feature_json) 
    our_json_configurations = configuration_json_to_our_json(configuration_json)

    # our_json_features.append(our_json_configurations)

    # return our_json_features
    return our_json_configurations

def get_doc_info(document_url: str) -> OnShapeDocInfo:
    """
    Builds a special variable url in order to fetch the variable data from the document through the Onshape API
    :param document_url: the url of the onshape document
    """
    m = re.match(r"^https?://cad.onshape.com/documents/([0-9a-f]+)/([wv])/([0-9a-f]+)/e/([0-9a-f]+)", document_url)
    if m is None: raise ValueError('invalid OnShape URL')
    return OnShapeDocInfo(m.group(1), m.group(2), m.group(3), m.group(4))


def get_variable_url(doc_info: OnShapeDocInfo) -> str:
    return f'https://cad.onshape.com/api/v5/variables/d/{doc_info.did}/{doc_info.wv}/{doc_info.wvid}/e/{doc_info.eid}/variables'

def get_configuration_url(doc_info: OnShapeDocInfo) -> str:
    return f'https://cad.onshape.com/api/v5/elements/d/{doc_info.did}/{doc_info.wv}/{doc_info.wvid}/e/{doc_info.eid}/configuration'


def fetch_document_variable_features_json(api_keys, api_url):
    """
    Takes an api_url and the api keys and fetches the variable document data
    :param api_url: the url that variables will be taken from
    :param api_keys: the api keys
    :return: the onshape document variables as a JSON
    """
    # Optional query parameters can be assigned 
    params = {'includeValuesAndReferencedVariables':True}

    # Define the header for the request 
    headers = {'Accept': 'application/json;charset=UTF-8;qs=0.09',
            'Content-Type': 'application/json'}

    # Putting everything together to make the API request 
    response = requests.get(api_url, 
                            params=params, 
                            auth=api_keys, 
                            headers=headers)

    return response.json()[0]['variables']

def fetch_document_configuration_json(api_keys, api_url):
    """
    Takes an api_url and the api keys and fetches the variable document data
    :param api_url: the url that variables will be taken from
    :param api_keys: the api keys
    :return: the onshape document variables as a JSON
    """
    # Optional query parameters can be assigned 
    params = {}

    # Define the header for the request 
    headers = {'Accept': 'application/json;charset=UTF-8;qs=0.09',
            'Content-Type': 'application/json'}

    # Putting everything together to make the API request 
    response = requests.get(api_url, 
                            params=params, 
                            auth=api_keys, 
                            headers=headers)
    json = response.json()
    if 'configurationParameters' not in json:
        raise ValueError(f'Bad request: {json}')
    return json['configurationParameters']


def feature_json_to_our_json(onshape_json):
    """
    Takes the JSON from the onshape file and formats it to our template
    :param onshape_json: the JSON generated by the call to onshape
    :return: Our JSON as a list of dicts
    """

    our_json = []
    for i, current_onshape_var in enumerate(onshape_json):
        # the elements attached to every variable
        name = current_onshape_var['name']
        desc = current_onshape_var['description']
        # default = current_onshape_var['initial']
        # group = current_onshape_var['group']
        type = current_onshape_var['type']

        if type == 'LENGTH':
            value, label = current_onshape_var['value'].split(' ')
            if label.lower() != "meter": raise RuntimeError('unknown LENGTH units')
            value = float(value)*1000 # convert to mm from meters
            label = 'mm'
        elif type == 'ANGLE':
            value, label = current_onshape_var['value'].split(' ')
            if label.lower() != "radian": raise RuntimeError('unknown ANGLE units')
            value = float(value)*180/math.pi
            label = 'degrees'
        elif type == 'NUMBER':
            value = current_onshape_var['value']
            value = float(value)
            label = ''
        elif type == 'ANY':
            value = current_onshape_var['value']
            label = ''

        m = OPTIONS_AT_START.match(desc)
        if m:
            pass
        

    # `[#]` - max (min is 0, step is 1)
    # * `[#:#]` - min and max (step is 1); if max is _ there is no max
    # * `[#:#:#]` - min, step, and max; if min or max is _ there is no min or max
    # * `[#, #, ...]` - set of possible options (drop box), units will convert options
    # * `[#:X, #:Y, ...]` - sets a number but shows X, Y, ... in a drop box

        format = m.group(1)
        desc = m.group(2)
        if ',' in format:
            parts = [x.strip() for x in format.split(',')]
            # for each part we need to detect : or not, make a dictionary of key to value based on the parts
        else:
            parts = [float(x.strip()) for x in format.split(':')]
            if len(parts) == 1:
                mn, mx, step = 0, parts[0], 1
            elif len(parts) == 2:
                mn, mx, step = parts[0], parts[1], 1
            elif len(parts) == 3:
                mn, mx, step = parts[0], parts[2], parts[1]
            else:
                error


        our_json.append(
            {
                'name': name,
                'desc': desc,
                'default': value,
                # 'group': group,
                'label': label
            }
        )

        # TODO: add functionality for groups and extra options within onshape description box
        # need to find out how to create groups, this method seems to completely avoid folders

        # # Extra Options
        # for extra in current_onshape_var:
        #     # The drop-down menu
        #     if extra == 'options':
        #         our_json[i]['style'] = 'dropdown'
        #         # todo: ask if this format is okay
        #         our_json[i]['options'] = current_onshape_var['options']

    # todo: change this and tests to output a string
    return our_json

def configuration_json_to_our_json(onshape_json):
    """
    Takes the JSON from the onshape file and formats it to our template
    :param onshape_json: the JSON generated by the call to onshape
    :return: Our JSON as a list of dicts
    """

    our_json = []
    for i, current_onshape_var in enumerate(onshape_json):
        current = current_onshape_var
        # the elements attached to every variable
        # name = current['name']
        # id = current['parameterId']
        # desc = current['description']
        # default = current['initial']
        # group = current['group']
        # type = current['type']
        # style = current['style]
        name = current['parameterName']

        new_var = {
            'id' : current['parameterId'],
        }

        if current_onshape_var['btType'] == 'BTMConfigurationParameterQuantity-1826':
            label = current['quantityType']
            current = current['rangeAndDefault']

            if current['btType'] == 'BTQuantityRange-181':
                new_var['style'] = 'numbox'

                new_var['default'] = current['defaultValue']
                new_var['max'] = current['maxValue']
                new_var['min'] = current['minValue']
                if label == 'INTEGER':
                    inc = '1'
                else:
                    match = INC_AT_END.match(name)
                    if match is not None:
                      name = name[:-len(match.groups(0))]
                      inc = float(match.groups(1))
                    else:
                      inc = 0.1

                new_var['name'] = name
                new_var['inc'] = inc
                

        if current_onshape_var['btType'] == 'BTMConfigurationParameterEnum-105':
            new_var['name'] = name
            new_var['style'] = 'dropdown'

            options = []
            for option in current['options']:
                option_name = option['optionName']
                options.append(option_name)
                if option['option'] == 'Default':
                    new_var['default'] = option_name
            
            new_var['options'] = options


        if current_onshape_var['btType'] == 'BTMConfigurationParameterBoolean-2550':
            new_var['name'] = name
            new_var['style'] = 'checkbox'
            new_var['default'] = current['defaultValue']

        if current_onshape_var['btType'] == 'BTMConfigurationParameterString-872':
            new_var['style'] = 'textbox'
            new_var['default'] = current['defaultValue']

            match = LEN_AT_END.match(name)
            if match is not None:
                name = name[:-len(match.groups(0))]
                new_var['max_len'] = int(match.groups(1))

            new_var['name'] = name

        our_json.append(new_var)

    return our_json